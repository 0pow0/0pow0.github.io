[{"content":"Locks Hardware primitives:\nTest-and-set Pseudo C code:\nWith the help of atomic test-and-set from hardware, simplest lock implementation would be spin-lock\nCons: not working on single CPU, since thread will spin on the while loop and thus owner of the lock get no chance to release this lock.\n","permalink":"https://0pow0.github.io/posts/os/thread/","summary":"Locks Hardware primitives:\nTest-and-set Pseudo C code:\nWith the help of atomic test-and-set from hardware, simplest lock implementation would be spin-lock\nCons: not working on single CPU, since thread will spin on the while loop and thus owner of the lock get no chance to release this lock.","title":"Thread"},{"content":"First-Order Recurrence Relations: ${a_n = sa_{n-1} + t}$ $a_n$ has this form: $a_n = c_1s^n+c_2$, $c_1, c_2$ solved by $$ a_0 = c_1+c_2\\newline a_1 = c_1s+c_2 $$\nSecond-Order Recurrence Relations: ${a_n = s_1a_{n-1} + s_2a_{n-2}}$ Case 1: $x^2 - s_1x - s_2 = 0$ has 2 root\n$a_n$ has this form $a_n = c_1r_1^n+ c_2r_2^n$, where $r_1, r_2$ is the roots. $c_1, c_2$ solved by $$ a_0 = c_1+c_2 \\newline a_1 = c_1r_1+ c_2r_2 $$\nCase 1: $x^2 - s_1x - s_2 = 0$ has 1 root\n$a_n$ has this form: $a_n = c_1r^n + c_2nr^n$, where $r$ is the root. $c_1, c_2$ solved by $$ a_0 = c_1 \\newline a_1 = c_1r+c_2r $$\n","permalink":"https://0pow0.github.io/posts/discrete_math/recurrence_relation/","summary":"First-Order Recurrence Relations: ${a_n = sa_{n-1} + t}$ $a_n$ has this form: $a_n = c_1s^n+c_2$, $c_1, c_2$ solved by $$ a_0 = c_1+c_2\\newline a_1 = c_1s+c_2 $$\nSecond-Order Recurrence Relations: ${a_n = s_1a_{n-1} + s_2a_{n-2}}$ Case 1: $x^2 - s_1x - s_2 = 0$ has 2 root\n$a_n$ has this form $a_n = c_1r_1^n+ c_2r_2^n$, where $r_1, r_2$ is the roots. $c_1, c_2$ solved by $$ a_0 = c_1+c_2 \\newline a_1 = c_1r_1+ c_2r_2 $$","title":"Recurrence Relations"},{"content":"面向对象设计原则 单一职责原则：Single Responsibility Principle, SRP\n一个类只负责一个功能领域中的相应职责。或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。\n开闭原则：Open-Closed Principle, OCP\n开闭原则是面向对象的可复用设计的第一块基石，它是最重要的面向对象设计原则\n一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量再不修改原有代码的情况下进行扩展。\n里氏代换原则：Liskov Substitution Principle, LSP\n所有引用父类的地方必须能透明的使用其子类的对象。\n依赖倒转原则：Dependence Inversion Principle, DIP\n抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。\n接口隔离原则：Interface Segregation Principle, ISP\n使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。\n合成复用原则：Composite Reuse Principle, CRP\n尽量使用对象组合，而不是继承来达到复用的目的。\n迪米特法则：Law of Demeter, LOD\n一个软件实体应该尽可能少地与其他实体发生相互作用。\n","permalink":"https://0pow0.github.io/posts/OOD_principles/","summary":"面向对象设计原则 单一职责原则：Single Responsibility Principle, SRP 一个类只负责一个功能领域中的相应职责。或者可以定义为：就一个类而言，应该只有一个引起它变化的","title":"Object Oriented Design Principles"},{"content":"单例模式 类只有唯一实例 自行创建这个实例 1 2 3 4 5 6 7 8 9 10 class TaskManager { private static TaskManager tm = null; private TaskManager() {...} public static TaskManager getInstance() { if (tm == null) { tm = new TaskManager(); } return tm; } } ","permalink":"https://0pow0.github.io/posts/design_pattern/creational_pattern/singleton_pattern/","summary":"单例模式 类只有唯一实例 自行创建这个实例 1 2 3 4 5 6 7 8 9 10 class TaskManager { private static TaskManager tm = null; private TaskManager() {...} public static TaskManager getInstance() { if (tm == null) { tm = new TaskManager(); } return tm; } }","title":"单例模式：Singleton Pattern"},{"content":"Class Diagram 类由三部分组成：\n类名\n属性\n1 可见性 名称:类型 [ = 默认值] 可见性 public: + private: - protected: # 方法\n1 可见性 名称(参数列表) [: 返回类型] 类与类之间的关系 关联关系：Association 一个类的对象作为另一个类的成员变量\n双向关联\n聚合关系：Arrgregation\n拥有不同的生命周期\n作为构造函数，Setter函数等的参数注\n组合关系：Composition\n相同的生命周期\n在构造函数中初始化\n依赖关系：Dependency 某个类的方法使用另一个类的对象作为参数\n泛化关系：Generalization 泛化关系就是继承关系\n接口与实现关系 接口中，通常没有属性，且所有操作都是抽象的，只有声明没有实现\n","permalink":"https://0pow0.github.io/posts/UML/diagram/class_diagram/","summary":"Class Diagram 类由三部分组成： 类名 属性 1 可见性 名称:类型 [ = 默认值] 可见性 public: + private: - protected: # 方法 1 可见性 名称(参数列表) [: 返回类型] 类与类之间的关系 关联关系","title":"Class Diagram"},{"content":"Function of one r.v. $Y = g(X)$\nX 是离散，Y也是离散 X是连续，Y是离散 将Y的取值一一列出，再将Y的各种取值的概率求出\nX是连续，Y是连续\n$g(x)$是严格单调函数 反函数$g^{-1}(y) = h(y)$有连续导函数，则$Y=g(X)$的PDF为 $$ \\begin{equation} p_{Y}(y) = \\begin{cases} p_{X}[h(y)]|h^\\prime(y)|, \u0026amp;a\u0026lt;y\u0026lt;b \\newline 0, \u0026amp;\\text{其他} \\end{cases} \\end{equation} $$ 例1: $X \\sim \\mathcal{N}(\\mu, \\sigma^2)$, 则当$a\\neq0$时，有$Y =aX+b$, 求$Y$的PDF\n结论1：$X\\sim \\mathcal{N}(\\mu, \\sigma^2)$ $Y = aX+b \\sim \\mathcal{N}(a\\mu+b, a^2\\sigma^2)$\n否则从$F_Y(y) = P(g(X) \\leq y)$先求CDF再找PDF Function of multiple r.v. X+Y X, Y 独立\n$p_Z(z) = \\int_{-\\infty}^{\\infty}p_X(z-y)p_Y(y)dy=\\int_{-\\infty}^{\\infty}p_X(x)p_Y(z-x)dx$\n","permalink":"https://0pow0.github.io/posts/prob/RVs/","summary":"Function of one r.v. $Y = g(X)$ X 是离散，Y也是离散 X是连续，Y是离散 将Y的取值一一列出，再将Y的各种取值的概率求出 X是连续，Y是连续 $g(x)$是严格单调函","title":"Computaion of Random Variables"},{"content":"正态（高斯）分布 $$ X \\sim \\mathcal{N}(\\mu,,\\sigma^{2}) $$\n$$ p(x) = \\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}}, -\\infty \u0026lt; x \u0026lt; \\infty $$\n$$ F(x) = \\frac{1}{\\sqrt{2\\pi}\\sigma}\\int_{-\\infty}^{x}e^{-\\frac{(t-\\mu)^2}{2\\sigma^2}}dt $$\n如果RV $X \\sim \\mathcal{N}(\\mu,,\\sigma^{2})$, 则可以化为标准正态分布$U = \\frac{X-\\mu}{\\sigma} \\sim \\mathcal{N}(0, 1)$\n$E[X] = \\mu$\n$Var[X] = \\sigma^2$\n若$X\\sim \\mathcal{N}(\\mu, \\sigma^2)$, $Y=aX+b \\sim \\mathcal{N}(a\\mu+b, a^2\\sigma^2)$\n若$X\\sim \\mathcal{N}(\\mu_1, \\sigma_1^2)$, $Y\\sim \\mathcal{N}(\\mu_2, \\sigma_2^2)$,\n$Z=X+Y\\sim \\mathcal{N}(\\mu_1+\\mu_2, \\sigma_1^2+\\sigma_2^2)$\n均匀分布 $X\\sim \\mathcal{U}(a,b)$ $$ \\begin{equation} p(x) = \\begin{cases} \\frac{1}{b-a}, \u0026amp;a \u0026lt; x \u0026lt; b \\newline 0, \u0026amp;其他 \\end{cases} \\end{equation} $$\n$$ \\begin{equation} F(x) = \\begin{cases} 0, \u0026amp;a \u0026lt; x \\newline \\frac{x-a}{b-a}, \u0026amp;a\\leq x \u0026lt; b \\newline 1, \u0026amp;x \\geq b \\end{cases} \\end{equation} $$\n$E[X] = \\frac{a+b}{2}$\n$Var[X] = \\frac{(b-a)^2}{12}$\n指数分布 $X \\sim Exp(\\lambda)$, 其中$\\lambda\u0026gt;0$ $$ \\begin{equation} p(x) = \\begin{cases} \\lambda e^{-\\lambda x}, \u0026amp;x \\geq0 \\newline 0, \u0026amp;x\u0026lt;0 \\end{cases} \\end{equation} $$\n$$ \\begin{equation} F(x) = \\begin{cases} 1 - e^{-\\lambda x}, \u0026amp;x\\geq0 \\newline 0, \u0026amp; x \u0026lt; 0 \\end{cases} \\end{equation} $$\n$$ \\begin{equation} \\begin{aligned} E[X] \u0026amp;= \\frac{1}{\\lambda}\\newline E[X^2] \u0026amp;= \\frac{2}{\\lambda^2}\\newline Var[X] \u0026amp;= \\frac{1}{\\lambda^2} \\end{aligned} \\end{equation} $$ $P(x\u0026gt;s) = e^{-\\lambda s}$\n无记忆性：$s \u0026gt; 0, t \u0026gt; 0$\n$P(X \u0026gt; s + t | X \u0026gt; s) = P(X \u0026gt; t)$\n","permalink":"https://0pow0.github.io/posts/prob/continuous_rvs/","summary":"正态（高斯）分布 $$ X \\sim \\mathcal{N}(\\mu,,\\sigma^{2}) $$ $$ p(x) = \\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}}, -\\infty \u0026lt; x \u0026lt; \\infty $$ $$ F(x) = \\frac{1}{\\sqrt{2\\pi}\\sigma}\\int_{-\\infty}^{x}e^{-\\frac{(t-\\mu)^2}{2\\sigma^2}}dt $$ 如果RV $X \\sim \\mathcal{N}(\\mu,,\\sigma^{2})$, 则可以化为标准正态分布$U = \\frac{X-\\mu}{\\sigma} \\sim \\mathcal{N}(0, 1)$ $E[X] = \\mu$ $Var[X] = \\sigma^2$ 若$X\\sim \\mathcal{N}(\\mu, \\sigma^2)$, $Y=aX+b \\sim","title":"Continuous RVs"},{"content":"期望 RV的函数的期望是函数值和prob的积的积分或导数\n$E[c] = c$, c是常数\n方差 方差的定义：偏差平方的期望\n偏差平方：$(X-E[X])^2$\n$Var[X] = E[(X-E[X])^2]$\n性质1 $Var[X] = E[X^2] - (E[X])^2$\n性质2 $Var[c] = 0$\n性质3 $Var[aX+b] = a^2Var[X]$\n协方差 $Cov(X, Y) = E[(X-E[X])(Y-E[Y])] = E[XY] - E[X]E[Y]$\n相关系数 $Corr(X, Y) = \\frac{Cov(X,Y)}{\\sqrt{Var(X)}\\sqrt{Var(Y)}}$\n","permalink":"https://0pow0.github.io/posts/prob/expectation/","summary":"期望 RV的函数的期望是函数值和prob的积的积分或导数 $E[c] = c$, c是常数 方差 方差的定义：偏差平方的期望 偏差平方：$(X-E[X])^2$ $Var[X] = E[(X-E[X])^2]$ 性","title":"Expectation"},{"content":"Directory just store (filename, inode) pair in it.\nHard link is just create another (filename, inode) pair under the directory.\nSoft link is the third file type beyond file and dir whose content is the linked-to filename, thus soft link has different inode number.\nSee,\nInode Given a free disk space, how to design file system on that?\nSperate this space into file system blocks Assign data region, inode table, bit map for data region and inode table and super block Data region: User file content\nInode table: inode information, like block number, file creation date, etc.\nBitmap: Record if the block is allocated.\nSuper block: Store information about this file system\nHow to access file (foo, 17)?\ninode = 17, inode address = inode_start_address + 17 * sizeof(inode) = 17 *256B = 4352B; Translate this byte address into sector address by 4352B / 512B = 8.5; Read from disk to fetch inode 17 Got disk pointer inside inode 17 and Read again from disk to get file content This method is called Direct disk pointer\nDrawbacks for this: when file grows larger than (12 disk pointer * 4KB block size), it will overflow.\nSolutions: Multi-Level Index:\nBasic idea:\nallocate a block in data region then make inode holds an indirect pointer to that block Inside the block, stores the disk address Then file becomes extendable.\nFor example, two-indirect pointer works like this:\nFree space management when new files being created, file system needs go through inode bitmap to find a free inode number to that file and also go through the data bitmap to find the blocks to allocate for this file.\n","permalink":"https://0pow0.github.io/posts/os/file/","summary":"Directory just store (filename, inode) pair in it.\nHard link is just create another (filename, inode) pair under the directory.\nSoft link is the third file type beyond file and dir whose content is the linked-to filename, thus soft link has different inode number.\nSee,\nInode Given a free disk space, how to design file system on that?\nSperate this space into file system blocks Assign data region, inode table, bit map for data region and inode table and super block Data region: User file content","title":"File System"},{"content":"CPU 和 I/O 设备交互的方式有：polling, Interrupt\n快的设备用：polling\n慢的设备用：Interrupt\nThus, if a device is fast, it may be best to poll; if it is slow, interrupts, which allow overlap, are best. If the speed of the device is not known, or sometimes fast and sometimes slow, it may be best to use a hybrid that polls for a little while and then, if the device is not yet finished, uses interrupts. This two-phased approach may achieve the best of both worlds.\nDMA (Direct Memory Access)\n怎么去除 c: CPU copy data from memory to device\nAns: Use an DMA Engine to do this tedius job\nHard Disk Drive $$ T_{I/O} = T_{seek} + T_{rotation}+T_{transfer} $$\nRAID RAID Level 0: 没有备份\n✅ Performance\n✅ Capacity\n❎ Reliability\nRAID 1: Mirroring\n每块盘增加一块备份盘\nRAID 4: Parity 增加奇偶校验盘\n问题：比如同时修改block 4 和block 13时，需要更新P1和P3\n，但是P1和P3在同一盘上，不能sitmultaneously地进行\nRAID 5: Rotating Parity ","permalink":"https://0pow0.github.io/posts/os/io/","summary":"CPU 和 I/O 设备交互的方式有：polling, Interrupt 快的设备用：polling 慢的设备用：Interrupt Thus, if a device is fast, it may be best to poll; if it is slow, interrupts, which allow overlap, are","title":"I/O"},{"content":" Hardware use base/bound reg to do address translation:\nif offset \u0026lt; bound:\nPhy Addr = base + offset\nSegmentation Each logic segmentation (code, stack and heap) assign a pair of base/bound reg to it and complemented with growing direction and permission:\nPaging Page table\nValid bit: whether this translation is valid or not. For example for unallocated page is not valid translation\nProtection bit: whether the process has the priviledge to access this page\nPresent bit: whether this page is in memory or disk\nDirty bit: whether this page has ever been modified since last swapped into memory\nTLB Use ASID to distinguish different process\nSegmentaion + Paging ","permalink":"https://0pow0.github.io/posts/os/memory/","summary":"Hardware use base/bound reg to do address translation:\nif offset \u0026lt; bound:\nPhy Addr = base + offset\nSegmentation Each logic segmentation (code, stack and heap) assign a pair of base/bound reg to it and complemented with growing direction and permission:\nPaging Page table\nValid bit: whether this translation is valid or not. For example for unallocated page is not valid translation\nProtection bit: whether the process has the priviledge to access this page","title":"Memory"},{"content":"Prefix Function: $\\pi[i]$ 给定一个字符串s的前缀函数$\\pi_s(i)$定义为：子串s[0: i]的相等的真前缀与真后缀的最长长度\nEx, s = abcadabc\n0 0 0 1 0 1 2 3\n$\\pi_s[0] = 0$, 规定$\\pi[0] = 0$\n$\\pi_s1 = 0$, ab没有相等的真前缀和真后缀\n$\\pi_s[2] = 0$, abc没有相等的真前缀和真后缀\n$\\pi_s[3] = 1$, abca有相等的真前缀和真后缀a\n$\\pi_s[4] = 0$, abcad没有相等的真前缀和真后缀\n$\\pi_s[5] = 1$, abcada有相等的真前缀和真后缀a\n$\\pi_s[6] = 2$, abcadab有相等的真前缀和真后缀ab\n$\\pi_s[7] = 3$, abcadabc有相等的真前缀和真后缀abc\nTODO: Brute force\nOverservation 1:\n$\\pi[i]$和$\\pi[i+1]$的差值最少为1，即$\\pi[i+1] \\leq \\pi[i] +1$\nReference: oi-wiki-prefix-function\n","permalink":"https://0pow0.github.io/posts/alg/str/prefix_and_kmp/","summary":"Prefix Function: $\\pi[i]$ 给定一个字符串s的前缀函数$\\pi_s(i)$定义为：子串s[0: i]的相等的真前缀与真后缀的最长长度 Ex, s = abcadabc 0 0 0 1 0 1 2 3 $\\pi_s[0] = 0$, 规","title":"Prefix function and KMP algorithm"},{"content":" fork() 创建一个和父进程一样的子进程，然后在子进程中return 0\n父进程中return子进程的pid\nexec()覆写当前进程的代码段，堆栈等，成功的call to exec从不返回\nSyscall and Trap How OS keep control of hardware and resources?\nAt Boot time, kernel intialize trap table for CPU.\nTrap: User mode -\u0026gt; Kernel Mode\nSave Reg to kernel stack (hardware) move to kernel mode jump to trap handler Return-from-trap: Kernel mode -\u0026gt; User mode\nRestore Reg from kernel stack (hardware) move to user mode jump to process next instruction Context Switch Save context: Regs, PC, Kernel stack pointers.\nSince Interrupt is handled by hardware, which means OS did not have control at that time, trap/return-from-trap handler will need kernel stack to stores those information so when OS take control, it would be able to get regs value.\nScheduling $T_{turnaround} = T_{complete} - T_{arrival}$\n$T_{response} = T_{first run} - T_{arrival}$\nFIFO SJF (Short Job First) 在同时到达的process中选择最短的\nSTCF (Shortest Time-to-Completion First) 抢占式的SJF\nGood for Turnaround time\nBad for Response Time\nRR(Round Robin) Good for Response Time\nBad for Turnaround Time\nI/O MLFQ(Multi-Level Feedback Queue) Rule 1: if $Priority(A) \u0026gt; Priority(B)$, A runs B doesn\u0026rsquo;t\nRule 2: if $Priority(A) = Priority(B)$, A and B run in RR\nRule 3: When a job enters the system, it is placed at the highest priority\nRule 4a: If a job uses up its time allotment at a given level, its priority is reduced\nHere allotment meas: Each level of queue has unique length of time slice\nRule 5: After some time period S, move all jobs in the system to the topmost queue\n","permalink":"https://0pow0.github.io/posts/os/process/","summary":"fork() 创建一个和父进程一样的子进程，然后在子进程中return 0 父进程中return子进程的pid exec()覆写当前进程的代码段，堆栈等，成功","title":"Process"},{"content":"The number of subset of A is $2^{|A|}$\n","permalink":"https://0pow0.github.io/posts/discrete_math/set/","summary":"The number of subset of A is $2^{|A|}$","title":"Set"},{"content":"Markov inequality if X \u0026gt; 0 and E[X] is small, then X is unlikely to be very large\nmarkov 给出了RV大于某个值的概率的上界\nif $X \\geq 0$ and $a \u0026gt; 0$, then $P(X\u0026gt;a) \\leq \\frac{E[X]}{a}$\nChebyshev inequality if the variance is small, then X is unlikely to be too far from the mean\nchebyshev 不等式给出了偏差大于等于某个值的概率的上界\n$P(|X-E[X]| \\geq \\epsilon) \\leq \\frac{Var(X)}{\\epsilon^2}$\nThe Weak Law of Large Numbers ","permalink":"https://0pow0.github.io/posts/prob/WLLN/","summary":"Markov inequality if X \u0026gt; 0 and E[X] is small, then X is unlikely to be very large markov 给出了RV大于某个值的概率的上界 if $X \\geq 0$ and $a \u0026gt; 0$, then $P(X\u0026gt;a) \\leq \\frac{E[X]}{a}$ Chebyshev inequality if the variance is small, then X is unlikely to be too far from the mean chebyshev 不等式给","title":"The Weak Law of Large Numbers"},{"content":"Unsupervised Domain Adaptation by Backpropagation Ganin, Yaroslav, and Victor Lempitsky. “Unsupervised Domain Adaptation by Backpropagation.” arXiv, February 27, 2015. https://doi.org/10.48550/arXiv.1409.7495.\nUsing $G_d$ as dissimilarity measurement of the distribution of target domain $T(\\bold{f}) = {G_f(\\bold{x};\\theta_f)|x\\sim T(\\bold{x})}$ and source domain $S(\\bold{f}) = {G_f(\\bold{x};\\theta_f)|x\\sim S(\\bold{x})}$, why this works?\ninput domain feature $G_d$\u0026rsquo;s output label for $G_d$ t T $f_t$ 0 1 one data sampe from training dataset of target domain 0 means source domain 1 means target domain Measure the dissimilarity of the two distribution is non-trivial due to high dimension and distribution continuous changing during training, so we can use $G_d$ to measure this dissimilarity, higher the $L_d$ means feature $f$ are more unlike the label, which means the dissimilarity.\nAssume $G_d$ is trained to be optimal, the $f_t$ is \u0026ldquo;GOOD\u0026rdquo; for $G_f$ if $G_d(f_t)$ is wrongly prediction results equals to 0 but should be 1. Because of this, $G_f$ should maximize the loss $L_d$\n","permalink":"https://0pow0.github.io/posts/papers/arxiv_1409_p_7495/","summary":"Unsupervised Domain Adaptation by Backpropagation Ganin, Yaroslav, and Victor Lempitsky. “Unsupervised Domain Adaptation by Backpropagation.” arXiv, February 27, 2015. https://doi.org/10.48550/arXiv.1409.7495.\nUsing $G_d$ as dissimilarity measurement of the distribution of target domain $T(\\bold{f}) = {G_f(\\bold{x};\\theta_f)|x\\sim T(\\bold{x})}$ and source domain $S(\\bold{f}) = {G_f(\\bold{x};\\theta_f)|x\\sim S(\\bold{x})}$, why this works?\ninput domain feature $G_d$\u0026rsquo;s output label for $G_d$ t T $f_t$ 0 1 one data sampe from training dataset of target domain 0 means source domain 1 means target domain Measure the dissimilarity of the two distribution is non-trivial due to high dimension and distribution continuous changing during training, so we can use $G_d$ to measure this dissimilarity, higher the $L_d$ means feature $f$ are more unlike the label, which means the dissimilarity.","title":"Unsupervised Domain Adaptation by Backpropagation"}]