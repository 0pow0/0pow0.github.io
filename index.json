[{"content":"Locks Hardware primitives:\nTest-and-set Pseudo C code:\nWith the help of atomic test-and-set from hardware, simplest lock implementation would be spin-lock\nCons: not working on single CPU, since thread will spin on the while loop and thus owner of the lock get no chance to release this lock.\n","permalink":"https://0pow0.github.io/posts/os/thread/","summary":"Locks Hardware primitives:\nTest-and-set Pseudo C code:\nWith the help of atomic test-and-set from hardware, simplest lock implementation would be spin-lock\nCons: not working on single CPU, since thread will spin on the while loop and thus owner of the lock get no chance to release this lock.","title":"Thread"},{"content":"First-Order Recurrence Relations: ${a_n = sa_{n-1} + t}$ $a_n$ has this form: $a_n = c_1s^n+c_2$, $c_1, c_2$ solved by $$ a_0 = c_1+c_2\\newline a_1 = c_1s+c_2 $$\nSecond-Order Recurrence Relations: ${a_n = s_1a_{n-1} + s_2a_{n-2}}$ Case 1: $x^2 - s_1x - s_2 = 0$ has 2 root\n$a_n$ has this form $a_n = c_1r_1^n+ c_2r_2^n$, where $r_1, r_2$ is the roots. $c_1, c_2$ solved by $$ a_0 = c_1+c_2 \\newline a_1 = c_1r_1+ c_2r_2 $$\nCase 1: $x^2 - s_1x - s_2 = 0$ has 1 root\n$a_n$ has this form: $a_n = c_1r^n + c_2nr^n$, where $r$ is the root. $c_1, c_2$ solved by $$ a_0 = c_1 \\newline a_1 = c_1r+c_2r $$\n","permalink":"https://0pow0.github.io/posts/discrete_math/recurrence_relation/","summary":"First-Order Recurrence Relations: ${a_n = sa_{n-1} + t}$ $a_n$ has this form: $a_n = c_1s^n+c_2$, $c_1, c_2$ solved by $$ a_0 = c_1+c_2\\newline a_1 = c_1s+c_2 $$\nSecond-Order Recurrence Relations: ${a_n = s_1a_{n-1} + s_2a_{n-2}}$ Case 1: $x^2 - s_1x - s_2 = 0$ has 2 root\n$a_n$ has this form $a_n = c_1r_1^n+ c_2r_2^n$, where $r_1, r_2$ is the roots. $c_1, c_2$ solved by $$ a_0 = c_1+c_2 \\newline a_1 = c_1r_1+ c_2r_2 $$","title":"Recurrence Relations"},{"content":"面向对象设计原则 单一职责原则：Single Responsibility Principle, SRP\n一个类只负责一个功能领域中的相应职责。或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。\n开闭原则：Open-Closed Principle, OCP\n开闭原则是面向对象的可复用设计的第一块基石，它是最重要的面向对象设计原则\n一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量再不修改原有代码的情况下进行扩展。\n里氏代换原则：Liskov Substitution Principle, LSP\n所有引用父类的地方必须能透明的使用其子类的对象。\n依赖倒转原则：Dependence Inversion Principle, DIP\n抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。\n接口隔离原则：Interface Segregation Principle, ISP\n使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。\n合成复用原则：Composite Reuse Principle, CRP\n尽量使用对象组合，而不是继承来达到复用的目的。\n迪米特法则：Law of Demeter, LOD\n一个软件实体应该尽可能少地与其他实体发生相互作用。\n","permalink":"https://0pow0.github.io/posts/OOD_principles/","summary":"面向对象设计原则 单一职责原则：Single Responsibility Principle, SRP 一个类只负责一个功能领域中的相应职责。或者可以定义为：就一个类而言，应该只有一个引起它变化的","title":"Object Oriented Design Principles"},{"content":"单例模式 类只有唯一实例 自行创建这个实例 1 2 3 4 5 6 7 8 9 10 class TaskManager { private static TaskManager tm = null; private TaskManager() {...} public static TaskManager getInstance() { if (tm == null) { tm = new TaskManager(); } return tm; } } ","permalink":"https://0pow0.github.io/posts/design_pattern/creational_pattern/singleton_pattern/","summary":"单例模式 类只有唯一实例 自行创建这个实例 1 2 3 4 5 6 7 8 9 10 class TaskManager { private static TaskManager tm = null; private TaskManager() {...} public static TaskManager getInstance() { if (tm == null) { tm = new TaskManager(); } return tm; } }","title":"单例模式：Singleton Pattern"},{"content":"Class Diagram 类由三部分组成：\n类名\n属性\n1 可见性 名称:类型 [ = 默认值] 可见性 public: + private: - protected: # 方法\n1 可见性 名称(参数列表) [: 返回类型] 类与类之间的关系 关联关系：Association 一个类的对象作为另一个类的成员变量\n双向关联\n聚合关系：Arrgregation\n拥有不同的生命周期\n作为构造函数，Setter函数等的参数注\n组合关系：Composition\n相同的生命周期\n在构造函数中初始化\n依赖关系：Dependency 某个类的方法使用另一个类的对象作为参数\n泛化关系：Generalization 泛化关系就是继承关系\n接口与实现关系 接口中，通常没有属性，且所有操作都是抽象的，只有声明没有实现\n","permalink":"https://0pow0.github.io/posts/UML/diagram/class_diagram/","summary":"Class Diagram 类由三部分组成： 类名 属性 1 可见性 名称:类型 [ = 默认值] 可见性 public: + private: - protected: # 方法 1 可见性 名称(参数列表) [: 返回类型] 类与类之间的关系 关联关系","title":"Class Diagram"},{"content":"期望 RV的函数的期望是函数值和prob的积的积分或导数\n$E[c] = c$, c是常数\n方差 方差的定义：偏差平方的期望\n偏差平方：$(X-E[X])^2$\n$Var[X] = E[(X-E[X])^2]$\n性质1 $Var[X] = E[X^2] - (E[X])^2$\n性质2 $Var[c] = 0$\n性质3 $Var[aX+b] = a^2Var[X]$\n","permalink":"https://0pow0.github.io/posts/prob/expectation/","summary":"期望 RV的函数的期望是函数值和prob的积的积分或导数 $E[c] = c$, c是常数 方差 方差的定义：偏差平方的期望 偏差平方：$(X-E[X])^2$ $Var[X] = E[(X-E[X])^2]$ 性","title":"Expectation"},{"content":"Directory just store (filename, inode) pair in it.\nHard link is just create another (filename, inode) pair under the directory.\nSoft link is the third file type beyond file and dir whose content is the linked-to filename, thus soft link has different inode number.\nSee,\nInode Given a free disk space, how to design file system on that?\nSperate this space into file system blocks Assign data region, inode table, bit map for data region and inode table and super block Data region: User file content\nInode table: inode information, like block number, file creation date, etc.\nBitmap: Record if the block is allocated.\nSuper block: Store information about this file system\nHow to access file (foo, 17)?\ninode = 17, inode address = inode_start_address + 17 * sizeof(inode) = 17 *256B = 4352B; Translate this byte address into sector address by 4352B / 512B = 8.5; Read from disk to fetch inode 17 Got disk pointer inside inode 17 and Read again from disk to get file content This method is called Direct disk pointer\nDrawbacks for this: when file grows larger than (12 disk pointer * 4KB block size), it will overflow.\nSolutions: Multi-Level Index:\nBasic idea:\nallocate a block in data region then make inode holds an indirect pointer to that block Inside the block, stores the disk address Then file becomes extendable.\nFor example, two-indirect pointer works like this:\nFree space management when new files being created, file system needs go through inode bitmap to find a free inode number to that file and also go through the data bitmap to find the blocks to allocate for this file.\n","permalink":"https://0pow0.github.io/posts/os/file/","summary":"Directory just store (filename, inode) pair in it.\nHard link is just create another (filename, inode) pair under the directory.\nSoft link is the third file type beyond file and dir whose content is the linked-to filename, thus soft link has different inode number.\nSee,\nInode Given a free disk space, how to design file system on that?\nSperate this space into file system blocks Assign data region, inode table, bit map for data region and inode table and super block Data region: User file content","title":"File System"},{"content":"CPU 和 I/O 设备交互的方式有：polling, Interrupt\n快的设备用：polling\n慢的设备用：Interrupt\nThus, if a device is fast, it may be best to poll; if it is slow, interrupts, which allow overlap, are best. If the speed of the device is not known, or sometimes fast and sometimes slow, it may be best to use a hybrid that polls for a little while and then, if the device is not yet finished, uses interrupts. This two-phased approach may achieve the best of both worlds.\nDMA (Direct Memory Access)\n怎么去除 c: CPU copy data from memory to device\nAns: Use an DMA Engine to do this tedius job\nHard Disk Drive $$ T_{I/O} = T_{seek} + T_{rotation}+T_{transfer} $$\nRAID RAID Level 0: 没有备份\n✅ Performance\n✅ Capacity\n❎ Reliability\nRAID 1: Mirroring\n每块盘增加一块备份盘\nRAID 4: Parity 增加奇偶校验盘\n问题：比如同时修改block 4 和block 13时，需要更新P1和P3\n，但是P1和P3在同一盘上，不能sitmultaneously地进行\nRAID 5: Rotating Parity ","permalink":"https://0pow0.github.io/posts/os/io/","summary":"CPU 和 I/O 设备交互的方式有：polling, Interrupt 快的设备用：polling 慢的设备用：Interrupt Thus, if a device is fast, it may be best to poll; if it is slow, interrupts, which allow overlap, are","title":"I/O"},{"content":" Hardware use base/bound reg to do address translation:\nif offset \u0026lt; bound:\nPhy Addr = base + offset\nSegmentation Each logic segmentation (code, stack and heap) assign a pair of base/bound reg to it and complemented with growing direction and permission:\nPaging Page table\nValid bit: whether this translation is valid or not. For example for unallocated page is not valid translation\nProtection bit: whether the process has the priviledge to access this page\nPresent bit: whether this page is in memory or disk\nDirty bit: whether this page has ever been modified since last swapped into memory\nTLB Use ASID to distinguish different process\nSegmentaion + Paging ","permalink":"https://0pow0.github.io/posts/os/memory/","summary":"Hardware use base/bound reg to do address translation:\nif offset \u0026lt; bound:\nPhy Addr = base + offset\nSegmentation Each logic segmentation (code, stack and heap) assign a pair of base/bound reg to it and complemented with growing direction and permission:\nPaging Page table\nValid bit: whether this translation is valid or not. For example for unallocated page is not valid translation\nProtection bit: whether the process has the priviledge to access this page","title":"Memory"},{"content":" fork() 创建一个和父进程一样的子进程，然后在子进程中return 0\n父进程中return子进程的pid\nexec()覆写当前进程的代码段，堆栈等，成功的call to exec从不返回\nSyscall and Trap How OS keep control of hardware and resources?\nAt Boot time, kernel intialize trap table for CPU.\nTrap: User mode -\u0026gt; Kernel Mode\nSave Reg to kernel stack (hardware) move to kernel mode jump to trap handler Return-from-trap: Kernel mode -\u0026gt; User mode\nRestore Reg from kernel stack (hardware) move to user mode jump to process next instruction Context Switch Save context: Regs, PC, Kernel stack pointers.\nSince Interrupt is handled by hardware, which means OS did not have control at that time, trap/return-from-trap handler will need kernel stack to stores those information so when OS take control, it would be able to get regs value.\n","permalink":"https://0pow0.github.io/posts/os/process/","summary":"fork() 创建一个和父进程一样的子进程，然后在子进程中return 0 父进程中return子进程的pid exec()覆写当前进程的代码段，堆栈等，成功","title":"Process"}]