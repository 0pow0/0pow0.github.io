[{"content":"First-Order Recurrence Relations: $a_n = sa_{n-1} + t$ $a_n$ has this form: $a_n = c_1s^n+c_2$, $c_1, c_2$ solved by $$ a_0 = c_1+c_2\\ a_1 = c_1s+c_2 $$\nSecond-Order Recurrence Relations: $a_n = s_1a_{n-1} + s_2a_{n-2}$ Case 1: $x^2 - s_1x - s_2 = 0$ has 2 root\n$a_n$ has this form $a_n = c_1r_1^n+ c_2r_2^n$, where $r_1, r_2$ is the roots. $c_1, c_2$ solved by $$ a_0 = c_1+c_2\\ a_1 = c_1r_1+ c_2r_2 $$\nCase 1: $x^2 - s_1x - s_2 = 0$ has 1 root\n$a_n$ has this form: $a_n = c_1r^n + c_2nr^n$, where $r$ is the root. $c_1, c_2$ solved by $$ a_0 = c_1\\ a_1 = c_1r+c_2r $$\n","permalink":"https://0pow0.github.io/posts/discrete_math/recurrence_relation/","summary":"First-Order Recurrence Relations: $a_n = sa_{n-1} + t$ $a_n$ has this form: $a_n = c_1s^n+c_2$, $c_1, c_2$ solved by $$ a_0 = c_1+c_2\\ a_1 = c_1s+c_2 $$\nSecond-Order Recurrence Relations: $a_n = s_1a_{n-1} + s_2a_{n-2}$ Case 1: $x^2 - s_1x - s_2 = 0$ has 2 root\n$a_n$ has this form $a_n = c_1r_1^n+ c_2r_2^n$, where $r_1, r_2$ is the roots. $c_1, c_2$ solved by $$ a_0 = c_1+c_2\\ a_1 = c_1r_1+ c_2r_2 $$","title":"Recurrence Relations"},{"content":"面向对象设计原则 单一职责原则：Single Responsibility Principle, SRP\n一个类只负责一个功能领域中的相应职责。或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。\n开闭原则：Open-Closed Principle, OCP\n开闭原则是面向对象的可复用设计的第一块基石，它是最重要的面向对象设计原则\n一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量再不修改原有代码的情况下进行扩展。\n里氏代换原则：Liskov Substitution Principle, LSP\n所有引用父类的地方必须能透明的使用其子类的对象。\n依赖倒转原则：Dependence Inversion Principle, DIP\n抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。\n接口隔离原则：Interface Segregation Principle, ISP\n使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。\n合成复用原则：Composite Reuse Principle, CRP\n尽量使用对象组合，而不是继承来达到复用的目的。\n迪米特法则：Law of Demeter, LOD\n一个软件实体应该尽可能少地与其他实体发生相互作用。\n","permalink":"https://0pow0.github.io/posts/OOD_principles/","summary":"面向对象设计原则 单一职责原则：Single Responsibility Principle, SRP 一个类只负责一个功能领域中的相应职责。或者可以定义为：就一个类而言，应该只有一个引起它变化的","title":"Object Oriented Design Principles"},{"content":"单例模式 类只有唯一实例 自行创建这个实例 1 2 3 4 5 6 7 8 9 10 class TaskManager { private static TaskManager tm = null; private TaskManager() {...} public static TaskManager getInstance() { if (tm == null) { tm = new TaskManager(); } return tm; } } ","permalink":"https://0pow0.github.io/posts/design_pattern/creational_pattern/singleton_pattern/","summary":"单例模式 类只有唯一实例 自行创建这个实例 1 2 3 4 5 6 7 8 9 10 class TaskManager { private static TaskManager tm = null; private TaskManager() {...} public static TaskManager getInstance() { if (tm == null) { tm = new TaskManager(); } return tm; } }","title":"单例模式：Singleton Pattern"},{"content":"Class Diagram 类由三部分组成：\n类名\n属性\n1 可见性 名称:类型 [ = 默认值] 可见性 public: + private: - protected: # 方法\n1 可见性 名称(参数列表) [: 返回类型] 类与类之间的关系 关联关系：Association 一个类的对象作为另一个类的成员变量\n双向关联\n聚合关系：Arrgregation\n拥有不同的生命周期\n作为构造函数，Setter函数等的参数注\n组合关系：Composition\n相同的生命周期\n在构造函数中初始化\n依赖关系：Dependency 某个类的方法使用另一个类的对象作为参数\n泛化关系：Generalization 泛化关系就是继承关系\n接口与实现关系 接口中，通常没有属性，且所有操作都是抽象的，只有声明没有实现\n","permalink":"https://0pow0.github.io/posts/UML/diagram/class_diagram/","summary":"Class Diagram 类由三部分组成： 类名 属性 1 可见性 名称:类型 [ = 默认值] 可见性 public: + private: - protected: # 方法 1 可见性 名称(参数列表) [: 返回类型] 类与类之间的关系 关联关系","title":"Class Diagram"}]